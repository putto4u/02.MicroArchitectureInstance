# Chapter 6-4. 데이터의 그룹화와 통계 (GROUP BY & Aggregate Functions)

데이터베이스의 진정한 가치는 개별 데이터를 저장하는 것을 넘어, 데이터를 요약하고 분석하여 **'정보(Information)'** 를 도출하는 데 있습니다. `GROUP BY`와 집계 함수는 엑셀의 '피벗 테이블'과 같은 역할을 수행하여 로우(Row) 레벨의 데이터를 통계 데이터로 변환합니다.

---

### 1. 집계 함수 (Aggregate Functions)

여러 행(Row)의 값을 입력받아 하나의 요약된 값(Scalar Value)을 반환하는 함수들입니다.

| 함수 | 설명 | 주의사항 (NULL 처리) |
| --- | --- | --- |
| **COUNT()** | 행의 개수를 셉니다. | `COUNT(*)`는 NULL 포함 모든 행을 세고, `COUNT(컬럼)`은 NULL을 제외하고 셉니다. |
| **SUM()** | 숫자의 합계를 구합니다. | NULL 값은 제외하고 계산합니다. |
| **AVG()** | 숫자의 평균을 구합니다. | **가장 주의:** NULL 값은 분모에서 빠집니다. (NULL을 0으로 치환하지 않으면 통계 왜곡 발생 가능) |
| **MAX() / MIN()** | 최댓값과 최솟값을 구합니다. | 숫자뿐만 아니라 날짜(가장 최근/과거), 문자열 순서에도 사용 가능합니다. |

### 2. GROUP BY 절: 데이터 묶기

`GROUP BY`는 특정 컬럼을 기준으로 동일한 값을 가진 행들을 하나의 그룹으로 묶습니다.

* **기본 원리:** "부서별로 묶어라", "직급별로 묶어라"와 같은 명령입니다.
* **문법 규칙:** `SELECT` 절에 집계 함수가 아닌 **일반 컬럼**이 있다면, 그 컬럼은 반드시 `GROUP BY` 절에 명시되어야 합니다.

```sql
-- 잘못된 쿼리 (에러 발생)
-- 이유: 부서별로 묶었는데, 집계되지 않은 '이름'을 출력하라고 하면 누구 이름을 낼지 DB는 모릅니다.
SELECT dept_id, name, AVG(salary) 
FROM employees 
GROUP BY dept_id;

-- 올바른 쿼리
-- 부서별(dept_id) 평균 급여 조회
SELECT dept_id, AVG(salary) AS avg_sal
FROM employees
GROUP BY dept_id;

```

### 3. HAVING 절: 그룹핑 후의 필터링

SQL을 처음 접할 때 가장 혼동하는 것이 `WHERE`와 `HAVING`의 차이입니다. 둘 다 데이터를 필터링하지만 **'시점'**이 다릅니다.

* **WHERE:** 그룹화 **하기 전**에 행을 걸러냅니다. (개별 데이터 필터링)
* **HAVING:** 그룹화 **한 후**에 집계된 결과를 걸러냅니다. (통계 데이터 필터링)

> **핵심 차이 예시:**
> * "연봉이 5000 이상인 **사람**을 제외하고 집계해라" -> **WHERE**
> * "부서 평균 연봉이 7000 이상인 **부서**만 보여달라" -> **HAVING**
> 
> 

```sql
SELECT dept_id, AVG(salary)
FROM employees
WHERE salary > 3000       -- 1차 필터: 연봉 3000 초과인 사람만 추려냄
GROUP BY dept_id          -- 2차 작업: 그 사람들을 부서별로 묶음
HAVING AVG(salary) > 5000; -- 3차 필터: 묶은 결과 중 평균이 5000 넘는 부서만 남김

```

### 4. (심화) NULL 데이터의 함정

`AVG()` 함수 사용 시 NULL 처리는 데이터 분석의 치명적인 오류를 유발할 수 있습니다.

* **상황:** 3명의 성적(100점, 100점, NULL)이 있을 때.
* **AVG(score):** `(100 + 100) / 2 = 100` (NULL인 사람을 아예 제외)
* **실제 의도:** 시험 안 본 사람을 0점 처리해야 한다면?


* **해결:** `IFNULL` (MySQL) 또는 `NVL` (Oracle) 함수를 사용하여 NULL을 0으로 치환해야 합니다.

```sql
-- MySQL 예시: NULL을 0으로 변환 후 평균 계산
SELECT AVG(IFNULL(score, 0)) FROM students;
-- 결과: (100 + 100 + 0) / 3 = 66.6

```

### 5. SQL 논리적 실행 순서 (Logical Execution Order)

DBMS가 SQL을 해석하는 순서를 이해하면 쿼리 작성 시 오류를 줄일 수 있습니다.

1. **FROM** (어느 테이블에서?)
2. **ON / JOIN** (어떻게 연결해서?)
3. **WHERE** (어떤 행을 가져올까? - 1차 필터)
4. **GROUP BY** (어떻게 묶을까?)
5. **HAVING** (어떤 그룹을 남길까? - 2차 필터)
6. **SELECT** (어떤 컬럼을 보여줄까?)
7. **ORDER BY** (어떻게 정렬할까?)

Next Step: 쿼리 안의 쿼리, 서브쿼리(Subquery)의 개념과 활용 (단일행/다중행)
