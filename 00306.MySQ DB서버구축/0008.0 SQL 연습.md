**employees** 샘플 데이터베이스의 구조를 완벽하게 숙달하기 위한 단계별 연습문제 50선입니다. 기초부터 고급 문법까지 순차적으로 구성하였습니다.

---

## 1. 기초 단계: SELECT 및 필터링 (1~15)

**Q1. 전체 직원 정보 조회**

* **문제:** `employees` 테이블의 모든 컬럼을 조회하세요.
* **답안:** `SELECT * FROM employees;`

**Q2. 특정 컬럼 조회**

* **문제:** 모든 직원의 이름(`first_name`)과 입사일(`hire_date`)만 조회하세요.
* **답안:** `SELECT first_name, hire_date FROM employees;`

**Q3. 별칭 사용 (Alias)**

* **문제:** `first_name`은 "이름", `last_name`은 "성"으로 표시하여 조회하세요.
* **답안:** `SELECT first_name AS 이름, last_name AS 성 FROM employees;`

**Q4. 중복 제거 (DISTINCT)**

* **문제:** 직원들이 가진 직책(`title`)의 종류를 중복 없이 조회하세요.
* **답안:** `SELECT DISTINCT title FROM titles;`

**Q5. 기본 조건문 (WHERE)**

* **문제:** 성별이 'F'인 여성 직원의 모든 정보를 조회하세요.
* **답안:** `SELECT * FROM employees WHERE gender = 'F';`

**Q6. 비교 연산자**

* **문제:** 급여(`salary`)가 150,000 이상인 데이터를 조회하세요.
* **답안:** `SELECT * FROM salaries WHERE salary >= 150000;`

**Q7. 논리 연산자 (AND)**

* **문제:** 성별이 'M'이면서 이름이 'Denis'인 직원을 조회하세요.
* **답안:** `SELECT * FROM employees WHERE gender = 'M' AND first_name = 'Denis';`

**Q8. 논리 연산자 (OR)**

* **문제:** 이름이 'Denis'이거나 'Elvis'인 직원을 조회하세요.
* **답안:** `SELECT * FROM employees WHERE first_name = 'Denis' OR first_name = 'Elvis';`

**Q9. IN 연산자**

* **문제:** 부서 번호(`dept_no`)가 'd001', 'd002', 'd003'인 부서 정보를 조회하세요.
* **답안:** `SELECT * FROM departments WHERE dept_no IN ('d001', 'd002', 'd003');`

**Q10. BETWEEN 연산자**

* **문제:** 1990년부터 1995년 사이에 입사한 직원을 조회하세요.
* **답안:** `SELECT * FROM employees WHERE hire_date BETWEEN '1990-01-01' AND '1995-12-31';`

**Q11. LIKE 연산자 (패턴 매칭)**

* **문제:** 이름이 'Mar'로 시작하는 모든 직원을 조회하세요.
* **답안:** `SELECT * FROM employees WHERE first_name LIKE 'Mar%';`

**Q12. LIKE 연산자 (포함)**

* **문제:** 이름에 'ba'가 포함된 직원을 조회하세요.
* **답안:** `SELECT * FROM employees WHERE first_name LIKE '%ba%';`

**Q13. NULL 확인**

* **문제:** `to_date`가 NULL인 데이터를 찾으세요. (실제 데이터에선 '9999-01-01'이 현재를 의미하지만 문법 연습용)
* **답안:** `SELECT * FROM salaries WHERE to_date IS NULL;`

**Q14. 정렬 (ORDER BY)**

* **문제:** 입사일이 빠른 순서대로 직원을 정렬하세요.
* **답안:** `SELECT * FROM employees ORDER BY hire_date ASC;`

**Q15. 정렬 (내림차순 및 다중 조건)**

* **문제:** 성(`last_name`)을 알파벳 역순으로 정렬하고, 성이 같으면 이름순으로 정렬하세요.
* **답안:** `SELECT * FROM employees ORDER BY last_name DESC, first_name ASC;`

---

## 2. 중급 단계: 집계 및 그룹화 (16~30)

**Q16. 데이터 개수 (COUNT)**

* **문제:** 전체 부서의 개수를 구하세요.
* **답안:** `SELECT COUNT(*) FROM departments;`

**Q17. 최댓값 (MAX)**

* **문제:** 전체 직원 중 가장 높은 급여를 얼마인지 구하세요.
* **답안:** `SELECT MAX(salary) FROM salaries;`

**Q18. 최솟값 (MIN)**

* **문제:** 가장 먼저 입사한 직원의 입사일을 구하세요.
* **답안:** `SELECT MIN(hire_date) FROM employees;`

**Q19. 평균값 (AVG)**

* **문제:** 전체 직원의 평균 급여를 구하세요.
* **답안:** `SELECT AVG(salary) FROM salaries;`

**Q20. 합계 (SUM)**

* **문제:** 사원번호 '10001'인 직원이 지금까지 받은 총 급여 합계를 구하세요.
* **답안:** `SELECT SUM(salary) FROM salaries WHERE emp_no = 10001;`

**Q21. 그룹화 (GROUP BY)**

* **문제:** 남녀 성별 인원수를 각각 구하세요.
* **답안:** `SELECT gender, COUNT(*) FROM employees GROUP BY gender;`



**Q23. 출력 제한 (LIMIT)**

* **문제:** 급여가 높은 상위 10명을 조회하세요.
* **답안:** `SELECT * FROM salaries ORDER BY salary DESC LIMIT 10;`

**Q24. 연도 추출 (YEAR)**

* **문제:** 1990년에 입사한 직원 수를 구하세요.
* **답안:** `SELECT COUNT(*) FROM employees WHERE YEAR(hire_date) = 1990;`

**Q25. 문자열 합치기 (CONCAT)**

* **문제:** 이름과 성을 합쳐서 'Full_Name'이라는 컬럼으로 조회하세요.
* **답안:** `SELECT CONCAT(first_name, ' ', last_name) AS Full_Name FROM employees;`

**Q26. 현재 날짜 기준 필터링**

* **문제:** 현재 직책을 유지하고 있는 데이터만 조회하세요. (to_date가 9999-01-01인 데이터)
* **답안:** `SELECT * FROM titles WHERE to_date = '9999-01-01';`

**Q27. 수학 연산**

* **문제:** 모든 직원의 급여를 10% 인상했을 때의 예상 급여를 조회하세요.
* **답안:** `SELECT emp_no, salary * 1.1 AS increased_salary FROM salaries;`

**Q28. 그룹 내 조건**

* **문제:** 각 사원번호별로 급여를 몇 번 받았는지(급여 변경 횟수) 조회하세요.
* **답안:** `SELECT emp_no, COUNT(*) FROM salaries GROUP BY emp_no;`

**Q29. 날짜 차이 계산**

* **문제:** 각 사원의 현재까지의 근속 일수를 구하세요.
* **답안:** `SELECT emp_no, DATEDIFF(NOW(), hire_date) FROM employees;`

**Q30. 특정 문자열 길이 조회**

* **문제:** 이름이 5글자인 직원들만 조회하세요.
* **답안:** `SELECT * FROM employees WHERE LENGTH(first_name) = 5;`

---

## 3. 고급 단계: 조인 및 서브쿼리 (31~50)

**Q22. 그룹화 조건 (HAVING)**

* **문제:** 평균 급여가 70,000 이상인 직책별 평균 급여를 구하세요.
* **답안:** `SELECT title, AVG(salary) FROM titles t JOIN salaries s ON t.emp_no = s.emp_no GROUP BY title HAVING AVG(salary) >= 70000;`


**Q31. INNER JOIN 기초**

* **문제:** 직원의 이름과 현재 직책을 조회하세요.
* **답안:** `SELECT e.first_name, t.title FROM employees e INNER JOIN titles t ON e.emp_no = t.emp_no WHERE t.to_date = '9999-01-01';`

**Q32. 3개 테이블 조인**

* **문제:** 직원의 이름, 부서명, 직책을 한 번에 조회하세요.
* **답안:** `SELECT e.first_name, d.dept_name, t.title FROM employees e JOIN dept_emp de ON e.emp_no = de.emp_no JOIN departments d ON de.dept_no = d.dept_no JOIN titles t ON e.emp_no = t.emp_no;`

**Q33. LEFT JOIN 활용**

* **문제:** 모든 부서와 해당 부서의 매니저 정보를 조회하세요. (매니저가 없는 부서도 표시)
* **답안:** `SELECT d.dept_name, dm.emp_no FROM departments d LEFT JOIN dept_manager dm ON d.dept_no = dm.dept_no;`

**Q34. 서브쿼리 (WHERE절)**

* **문제:** 전체 평균 급여보다 높은 급여를 받는 사원들의 사원번호를 조회하세요.
* **답안:** `SELECT emp_no, salary FROM salaries WHERE salary > (SELECT AVG(salary) FROM salaries);`

**Q35. 서브쿼리 (IN)**

* **문제:** 'Marketing' 부서에 속한 직원들의 정보를 조회하세요.
* **답안:** `SELECT * FROM employees WHERE emp_no IN (SELECT emp_no FROM dept_emp WHERE dept_no = (SELECT dept_no FROM departments WHERE dept_name = 'Marketing'));`

**Q36. SELF JOIN**

* **문제:** 같은 날 입사한 직원 쌍을 찾으세요. (실제 데이터 양이 많으므로 10개만)
* **답안:** `SELECT e1.emp_no, e2.emp_no, e1.hire_date FROM employees e1 JOIN employees e2 ON e1.hire_date = e2.hire_date WHERE e1.emp_no <> e2.emp_no LIMIT 10;`

**Q37. 부서별 평균 급여**

* **문제:** 부서별로 평균 급여를 계산하여 부서명과 함께 출력하세요.
* **답안:** `SELECT d.dept_name, AVG(s.salary) FROM departments d JOIN dept_emp de ON d.dept_no = de.dept_no JOIN salaries s ON de.emp_no = s.emp_no GROUP BY d.dept_name;`

**Q38. 직책별 최고 급여**

* **문제:** 각 직책별로 가장 높은 급여를 받는 금액을 조회하세요.
* **답안:** `SELECT t.title, MAX(s.salary) FROM titles t JOIN salaries s ON t.emp_no = s.emp_no GROUP BY t.title;`

**Q39. EXISTS 사용**

* **문제:** 급여 기록이 한 번이라도 있는 직원의 정보를 조회하세요.
* **답안:** `SELECT * FROM employees e WHERE EXISTS (SELECT 1 FROM salaries s WHERE s.emp_no = e.emp_no);`

**Q40. UNION 연산자**

* **문제:** 'd001' 부서 직원 번호와 'd002' 부서 직원 번호를 합쳐서 출력하세요.
* **답안:** `SELECT emp_no FROM dept_emp WHERE dept_no = 'd001' UNION SELECT emp_no FROM dept_emp WHERE dept_no = 'd002';`

**Q41. 나이 계산 (현재 날짜 기준)**

* **문제:** 각 직원의 현재 나이를 구하세요.
* **답안:** `SELECT first_name, YEAR(CURDATE()) - YEAR(birth_date) AS age FROM employees;`

**Q42. CASE 문 (조건별 치환)**

* **문제:** 급여가 10만 이상이면 'High', 아니면 'Low'로 표시하세요.
* **답안:** `SELECT emp_no, salary, CASE WHEN salary >= 100000 THEN 'High' ELSE 'Low' END AS level FROM salaries;`

**Q43. 특정 부서 매니저 이름**

* **문제:** 'Finance' 부서의 현재 매니저 이름을 조회하세요.
* **답안:** `SELECT e.first_name, e.last_name FROM employees e JOIN dept_manager dm ON e.emp_no = dm.emp_no JOIN departments d ON dm.dept_no = d.dept_no WHERE d.dept_name = 'Finance' AND dm.to_date = '9999-01-01';`

**Q44. 고용 기간별 순위**

* **문제:** 가장 오래 근무한 직원 5명을 찾으세요.
* **답안:** `SELECT *, DATEDIFF(NOW(), hire_date) AS days FROM employees ORDER BY days DESC LIMIT 5;`

**Q45. 이름 중복 확인**

* **문제:** 동일한 이름을 가진 직원이 몇 명인지 이름별로 카운트하세요.
* **답안:** `SELECT first_name, COUNT(*) FROM employees GROUP BY first_name HAVING COUNT(*) > 1;`

**Q46. 데이터 타입 변환 (CAST)**

* **문제:** 사원번호를 문자열 타입으로 변환하여 조회하세요.
* **답안:** `SELECT CAST(emp_no AS CHAR) FROM employees;`

**Q47. 부서 이동 기록 확인**

* **문제:** 부서를 2번 이상 옮긴 직원의 번호를 조회하세요.
* **답안:** `SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(dept_no) > 1;`

**Q48. 특정 달에 태어난 직원**

* **문제:** 2월에 태어난 직원들을 조회하세요.
* **답안:** `SELECT * FROM employees WHERE MONTH(birth_date) = 2;`

**Q49. 급여 등급별 인원수**

* **문제:** 5만 미만, 5만~10만, 10만 초과인 인원수를 각각 구하세요.
* **답안:** `SELECT CASE WHEN salary < 50000 THEN 'C' WHEN salary BETWEEN 50000 AND 100000 THEN 'B' ELSE 'A' END AS grade, COUNT(*) FROM salaries WHERE to_date = '9999-01-01' GROUP BY grade;`

**Q50. 최신 정보 업데이트 확인**

* **문제:** 각 사원별로 가장 최근의 직책 시작일을 조회하세요.
* **답안:** `SELECT emp_no, MAX(from_date) FROM titles GROUP BY emp_no;`

---

> [!IMPORTANT]
> **과금 및 유료 서비스 안내**
> * **AWS RDS 성능:** 위와 같이 `JOIN`이 많거나 `GROUP BY`를 사용하는 50개의 복합 쿼리를 실행할 때, 인스턴스 사양(t2.micro 등)이 낮으면 CPU 사용량이 급증할 수 있습니다.
> * **CloudWatch 모니터링:** 쿼리 실행 중 성능 저하가 발생한다면 AWS CloudWatch를 통해 지표를 확인하세요. (일정량 초과 시 과금 발생 가능)
> 
> 

Next Step: 인덱스(Index) 최적화 및 쿼리 성능 튜닝

---

사용자 맞춤 설정에 따라 강의 교재 형식으로 50문제를 구성하였습니다. 깃허브 마크다운 형식을 준수하며, 모든 문제에 모범 답안을 포함했습니다.

SQL 50문제 | 집계함수 | 서브쿼리 실습 | JOIN 완벽 가이드
