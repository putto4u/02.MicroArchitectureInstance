
## [Section 2] 모범 답안 (Model Answers)

### Part 1 답안

```sql
-- 1. 동명이인
SELECT first_name, last_name, COUNT(*) as cnt FROM employees GROUP BY first_name, last_name HAVING cnt > 1;
-- 2. 특정 기간 입사자
SELECT e.emp_no FROM employees e JOIN titles t ON e.emp_no = t.emp_no WHERE e.hire_date BETWEEN '1990-01-01' AND '1995-12-31' AND t.title = 'Senior Engineer' AND t.to_date = '9999-01-01';
-- 3. 퇴사자
SELECT emp_no, dept_no FROM dept_emp WHERE to_date != '9999-01-01';
-- 4. 연봉 10만 이상
SELECT emp_no, MAX(salary) FROM salaries GROUP BY emp_no HAVING MAX(salary) >= 100000;
-- 5. 여성 매니저
SELECT e.emp_no, e.first_name FROM employees e JOIN dept_manager dm ON e.emp_no = dm.emp_no WHERE e.gender = 'F' AND dm.to_date = '9999-01-01';
-- 6. 이름 마스킹
SELECT first_name, CONCAT(LEFT(last_name, 1), REPEAT('*', LENGTH(last_name)-1)) FROM employees;
-- 7. 장기 근속자
SELECT emp_no FROM employees WHERE DATEDIFF(CURDATE(), hire_date) >= 10000;
-- 8. 부서명 정렬
SELECT de.emp_no, d.dept_name FROM dept_emp de JOIN departments d ON de.dept_no = d.dept_no ORDER BY d.dept_name, de.emp_no;
-- 9. 이달의 생일
SELECT emp_no FROM employees WHERE MONTH(birth_date) = MONTH(CURDATE());
-- 10. 직급별 평균 나이
SELECT t.title, AVG(YEAR(CURDATE())-YEAR(e.birth_date)) FROM employees e JOIN titles t ON e.emp_no = t.emp_no WHERE t.to_date = '9999-01-01' GROUP BY t.title;

```

### Part 2 답안

```sql
-- 11. 부서별 최고 연봉
SELECT d.dept_name, MAX(s.salary) FROM departments d JOIN dept_emp de ON d.dept_no = de.dept_no JOIN salaries s ON de.emp_no = s.emp_no WHERE s.to_date = '9999-01-01' GROUP BY d.dept_name;
-- 12. 연봉 상승 횟수
SELECT emp_no, COUNT(*)-1 as cnt FROM salaries GROUP BY emp_no ORDER BY cnt DESC LIMIT 10;
-- 13. 부서 이동 기록
SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(dept_no) >= 2;
-- 14. 연도별 채용
SELECT YEAR(hire_date) as yr, COUNT(*) FROM employees GROUP BY yr ORDER BY yr;
-- 15. 대규모 부서
SELECT d.dept_name, COUNT(*) as cnt FROM departments d JOIN dept_emp de ON d.dept_no = de.dept_no WHERE de.to_date = '9999-01-01' GROUP BY d.dept_name HAVING cnt >= 50000;
-- 16. 성별 임금 격차
SELECT gender, AVG(salary) FROM employees e JOIN salaries s ON e.emp_no = s.emp_no WHERE s.to_date = '9999-01-01' GROUP BY gender;
-- 17. 직급별 성비
SELECT title, gender, COUNT(*) FROM employees e JOIN titles t ON e.emp_no = t.emp_no WHERE t.to_date = '9999-01-01' GROUP BY title, gender;
-- 18. 매니저 연령 극단치
SELECT MIN(birth_date), MAX(birth_date) FROM employees e JOIN dept_manager dm ON e.emp_no = dm.emp_no WHERE dm.to_date = '9999-01-01';
-- 19. 부서별 평균 근속
SELECT d.dept_name, ROUND(AVG(DATEDIFF(IF(de.to_date='9999-01-01', CURDATE(), de.to_date), e.hire_date)/365), 1) FROM employees e JOIN dept_emp de ON e.emp_no = de.emp_no JOIN departments d ON de.dept_no = d.dept_no GROUP BY d.dept_name;
-- 20. 연봉 구간별 통계
SELECT FLOOR(salary/10000)*10000 as range_val, COUNT(*) FROM salaries WHERE to_date = '9999-01-01' GROUP BY range_val ORDER BY range_val;

```

### Part 3 답안

```sql
-- 21. 부서 평균 상회
SELECT e.emp_no, s.salary FROM employees e JOIN salaries s ON e.emp_no = s.emp_no JOIN dept_emp de ON e.emp_no = de.emp_no WHERE s.to_date = '9999-01-01' AND de.to_date = '9999-01-01' AND s.salary > (SELECT AVG(s2.salary) FROM salaries s2 JOIN dept_emp de2 ON s2.emp_no = de2.emp_no WHERE de2.dept_no = de.dept_no AND s2.to_date = '9999-01-01');
-- 22. 최단기 매니저
SELECT emp_no, DATEDIFF(to_date, from_date) as dur FROM dept_manager ORDER BY dur ASC LIMIT 1;
-- 23. 매니저보다 높은 연봉
SELECT de.emp_no FROM dept_emp de JOIN salaries s ON de.emp_no = s.emp_no JOIN dept_manager dm ON de.dept_no = dm.dept_no JOIN salaries s2 ON dm.emp_no = s2.emp_no WHERE s.to_date='9999-01-01' AND s2.to_date='9999-01-01' AND dm.to_date='9999-01-01' AND s.salary > s2.salary;
-- 24. 직급 변경 없음
SELECT emp_no FROM titles GROUP BY emp_no HAVING COUNT(title) = 1;
-- 25. 부서 내 상위 3명
SELECT * FROM (SELECT e.emp_no, de.dept_no, s.salary, DENSE_RANK() OVER (PARTITION BY de.dept_no ORDER BY s.salary DESC) as rnk FROM employees e JOIN dept_emp de ON e.emp_no = de.emp_no JOIN salaries s ON e.emp_no = s.emp_no WHERE s.to_date = '9999-01-01' AND de.to_date = '9999-01-01') t WHERE rnk <= 3;
-- 26. 누적 합계
SELECT emp_no, salary, SUM(salary) OVER (ORDER BY emp_no) as cumulative_sum FROM salaries WHERE to_date = '9999-01-01' LIMIT 100;
-- 27. 연봉 상승률
SELECT s1.emp_no, (s2.salary - s1.salary)/s1.salary*100 FROM (SELECT emp_no, salary FROM salaries GROUP BY emp_no HAVING MIN(from_date)) s1 JOIN (SELECT emp_no, salary FROM salaries WHERE to_date = '9999-01-01') s2 ON s1.emp_no = s2.emp_no;
-- 28. 빈 부서 확인
SELECT dept_name FROM departments d WHERE NOT EXISTS (SELECT 1 FROM dept_emp de WHERE de.dept_no = d.dept_no);
-- 29. 평균 대비 편차
SELECT emp_no, salary - (SELECT AVG(salary) FROM salaries WHERE to_date = '9999-01-01') FROM salaries WHERE to_date = '9999-01-01';
-- 30. 매니저 이름 매칭
SELECT e.first_name, m.first_name FROM employees e JOIN dept_emp de ON e.emp_no = de.emp_no JOIN dept_manager dm ON de.dept_no = dm.dept_no JOIN employees m ON dm.emp_no = m.emp_no WHERE de.to_date = '9999-01-01' AND dm.to_date = '9999-01-01';

```

---

## AWS 인프라 운영 및 과금 관리 포인트

1. **AWS RDS 성능 최적화**: 위 문제 중 **윈도우 함수(25, 26번)**나 **상관 서브쿼리(21번)**는 실행 시 많은 시스템 자원을 소모합니다. CPU 사용률이 급증할 경우 **CloudWatch 알람**을 설정하여 모니터링하세요.
2. **Aurora I/O 비용**: Amazon Aurora를 사용할 경우, 조인과 전체 스캔이 많은 쿼리는 읽기 I/O 발생량을 높여 **유료 과금**의 원인이 됩니다. 실행 전 `EXPLAIN`을 통해 인덱스 활용 여부를 반드시 확인하십시오.
3. **과금 주의 및 정리**:
* 실습용 RDS 인스턴스는 사용하지 않을 때 **중지(Stop)**해도 좋으나, 7일 후 자동 시작되므로 장기 미사용 시 **삭제(Delete)**를 권장합니다.
* 삭제 시 **'최종 스냅샷 생성'** 기능을 활용하면 나중에 데이터 손실 없이 복구할 수 있습니다. (스냅샷 저장 비용은 별도 발생)



요청하신 개인별 맞춤 설정을 모두 확인하여 작성하였습니다.

Next Step: 실습 결과 검증 및 데이터 무결성 체크 (Data Validation)

Next Step: AWS RDS 파라미터 그룹 최적화 (DB Parameter Tuning)

Next Step: SQL 성능 향상을 위한 인덱스 설계 전략 (Indexing Strategy)

데이터 검증 / 파라미터 튜닝 / 인덱스 전략
