## Nginx: 패키지 설치 vs Docker 컨테이너 비교

실무에서 Nginx를 운영할 때 OS에 직접 설치하는 방식과 Docker 컨테이너를 사용하는 방식은 각각 명확한 장단점이 있습니다. 결론부터 말씀드리면, **배포의 편의성과 환경 일관성 측면에서는 Docker를 사용하는 것이 압도적으로 유리합니다.**

---

### 1. 방식별 비교 분석

| 비교 항목 | OS 직접 설치 (APT/YUM) | Docker 컨테이너 사용 |
| --- | --- | --- |
| **설치 속도** | 의존성 패키지 설치 필요로 상대적으로 느림 | 이미지 기반으로 수 초 내 실행 가능 |
| **환경 격리** | OS 전역 설정에 영향을 받음 | 호스트 OS와 격리된 독립 환경 유지 |
| **버전 관리** | 여러 버전을 동시에 띄우기 어려움 | 태그(Tag)를 통해 다양한 버전 병행 운용 가능 |
| **이식성** | 서버 교체 시 재설정 과정이 복잡함 | `docker-compose.yml` 파일 하나로 어디든 복제 가능 |
| **리소스 관리** | 호스트 리소스를 직접 공유 | 컨테이너 단위로 CPU, 메모리 제한 가능 |

---
# Chapter 4-2. Ubuntu Nginx 웹 서버 구축 및 구성 (CLI 통합 스크립트)

```bash
#!/bin/bash
# ==============================================================================
# Ubuntu Nginx 웹 서버 구축 및 구성 (CLI 통합 스크립트)
# ==============================================================================

# 1. 패키지 인덱스 업데이트
# ------------------------------------------------------------------------------
# [sudo] root 권한으로 명령어를 실행합니다.
# [apt update] /etc/apt/sources.list에 등록된 리포지토리에서 최신 패키지 정보를 가져옵니다.
# 실제 설치 전에 패키지 목록을 최신 상태로 갱신하여 의존성 문제를 방지합니다.
sudo apt update

# 2. Nginx 설치
# ------------------------------------------------------------------------------
# [install nginx] Nginx 웹 서버 패키지를 설치합니다.
# [-y] 설치 과정에서 발생하는 "계속하시겠습니까? [Y/n]" 질문에 자동으로 Yes로 응답합니다.
sudo apt install nginx -y

# 3. 방화벽(UFW) 설정
# ------------------------------------------------------------------------------
# [ufw allow] Uncomplicated Firewall(방화벽) 규칙을 추가합니다.
# ['Nginx HTTP'] Nginx 설치 시 사전 정의된 애플리케이션 프로필로, 80번 포트(HTTP)를 허용합니다.
# AWS EC2 사용 시: 이 설정 외에도 AWS 콘솔의 '보안 그룹(Security Group)'에서 80번 포트 인바운드 규칙을 추가해야 합니다.
sudo ufw allow 'Nginx HTTP'

# [ufw status] 현재 방화벽의 활성화 상태와 적용된 규칙 목록을 출력합니다.
# 'Nginx HTTP' 항목이 'ALLOW'로 표시되는지 확인하는 단계입니다.
sudo ufw status

# 4. 서비스 상태 확인 및 구동 테스트
# ------------------------------------------------------------------------------
# [systemctl status] systemd 시스템 및 서비스 관리자를 통해 Nginx 서비스 상태를 조회합니다.
# 출력 결과에 'Active: active (running)'이 표시되어야 정상적으로 실행 중인 것입니다.
systemctl status nginx

# [curl] 명령줄 기반의 데이터 전송 도구입니다.
# [-4] IPv4 주소만 사용하도록 강제합니다.
# [icanhazip.com] 외부에서 접속 가능한 현재 서버의 공인 IP(Public IP)를 반환하는 서비스입니다.
# 브라우저 주소창에 이 IP를 입력하여 Nginx 기본 페이지("Welcome to nginx!")가 뜨는지 확인합니다.
curl -4 icanhazip.com

# 5. Server Block(가상 호스트) 설정
# ------------------------------------------------------------------------------
# 5.1 웹 루트 디렉터리 생성
# [mkdir] 디렉터리(폴더)를 생성하는 명령어입니다.
# [-p] 상위 디렉터리가 없으면 에러 없이 자동으로 함께 생성합니다(parents).
# '/var/www/example.com/html' 경로는 실제 웹 사이트의 파일들이 위치할 곳입니다.
sudo mkdir -p /var/www/example.com/html

# 5.2 소유권 및 권한 설정
# [chown] 파일이나 디렉터리의 소유자(Owner)와 그룹(Group)을 변경합니다.
# [-R] 하위 디렉터리와 파일까지 재귀적(Recursive)으로 적용합니다.
# [$USER:$USER] 현재 스크립트를 실행 중인 사용자 계정을 소유자와 그룹으로 지정합니다.
# 이를 통해 관리자 권한(sudo) 없이도 해당 디렉터리에 파일을 생성하거나 수정할 수 있게 됩니다.
sudo chown -R $USER:$USER /var/www/example.com/html

# [chmod] 파일이나 디렉터리의 허가권(Permission)을 변경합니다.
# [-R] 하위 항목까지 재귀적으로 적용합니다.
# [755] 소유자(7=rwx), 그룹(5=rx), 기타 사용자(5=rx) 권한을 부여합니다.
# 웹 서버(Nginx)가 해당 파일을 읽을 수 있어야 하므로 기타 사용자에게 읽기/실행 권한을 줍니다.
sudo chmod -R 755 /var/www/example.com

# 5.3 테스트용 index.html 생성
# [cat <<EOF > 파일경로] Here Document 문법을 사용하여 여러 줄의 텍스트를 파일로 저장합니다.
# '>' 연산자는 파일을 새로 생성하거나 덮어씁니다.
cat <<EOF > /var/www/example.com/html/index.html
<html>
    <head>
        <title>Welcome to Example.com!</title>
    </head>
    <body>
        <h1>Success! The Nginx server block is working!</h1>
    </body>
</html>
EOF
# [EOF] 입력 종료를 알리는 구분자입니다.

# 5.4 Server Block 설정 파일 생성
# [bash -c] 단일 문자열 내의 전체 명령을 실행하기 위해 새로운 bash 쉘을 호출합니다.
# 관리자 권한(sudo)으로 리다이렉션(>)을 처리하기 위해 사용합니다.
sudo bash -c 'cat <<EOF > /etc/nginx/sites-available/example.com
server {
    # [listen 80] IPv4 80번 포트에서 요청을 수신합니다.
    listen 80;
    # [listen [::]:80] IPv6 80번 포트에서 요청을 수신합니다.
    listen [::]:80;

    # [root] 이 가상 호스트가 사용할 웹 문서의 최상위 디렉터리(Document Root)를 지정합니다.
    root /var/www/example.com/html;

    # [index] 기본 페이지로 사용할 파일들의 우선순위를 지정합니다.
    # 사용자가 파일명 없이 도메인만으로 접속했을 때 index.html 등을 찾아서 보여줍니다.
    index index.html index.htm index.nginx-debian.html;

    # [server_name] 이 설정이 적용될 도메인 이름 또는 IP 주소를 지정합니다.
    # 클라이언트가 요청한 Host 헤더와 이 값을 비교하여 해당 서버 블록을 선택합니다.
    server_name example.com www.example.com;

    # [location /] 도메인 루트(/)로 들어오는 모든 요청에 대한 처리 규칙입니다.
    location / {
        # [try_files] 요청된 파일($uri)이 있는지 확인하고, 없으면 디렉터리($uri/)를 확인합니다.
        # 그래도 없으면 404 Not Found 에러를 반환합니다.
        try_files \$uri \$uri/ =404;
    }
}
EOF'

# 5.5 설정 활성화 (Symbolic Link)
# [ln -s] 원본 파일에 대한 바로 가기(심볼릭 링크)를 생성합니다.
# Nginx는 'sites-enabled' 디렉터리에 있는 설정 파일만 실제로 로드합니다.
# 'sites-available'에 원본을 두고, 'sites-enabled'에 링크를 걸어 관리하는 것이 표준 방식입니다.
sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/

# 6. 설정 검증 및 서비스 재시작
# ------------------------------------------------------------------------------
# 6.1 문법 검사
# [nginx -t] Nginx 설정 파일들의 문법 오류(Syntax Error)를 검사합니다.
# 재시작 전에 오타나 잘못된 설정이 없는지 확인하여 서비스 중단을 방지합니다.
sudo nginx -t

# 6.2 Nginx 설정 다시 불러오기
# [systemctl reload] 서비스를 완전히 중지했다가 다시 켜는(restart) 대신,
# 실행 중인 프로세스를 유지하면서 변경된 설정 파일만 다시 읽어들입니다.
# 연결 끊김 없이 설정을 적용할 수 있어 운영 환경에서 권장됩니다.
sudo systemctl reload nginx

# 7. (보충) 부팅 시 자동 시작 설정 확인
# ------------------------------------------------------------------------------
# [systemctl enable] 서버가 재부팅되더라도 Nginx 서비스가 자동으로 시작되도록 설정합니다.
# Ubuntu에서 apt로 설치 시 기본적으로 설정되지만, 확실하게 하기 위해 실행합니다.
sudo systemctl enable nginx

```

Next Step: Server Block 설정 파일의 세부 지시어(Directive) 심화 분석
---
### 2. Docker 기반 Nginx 구축 (CLI 실습)

Docker를 사용하여 Nginx를 실행할 경우, 기존의 복잡한 설정 과정을 단 몇 줄의 명령어로 대체할 수 있습니다.

```bash
# 1. Nginx 공식 이미지 다운로드 및 컨테이너 실행
# -p 80:80 : 호스트의 80번 포트와 컨테이너의 80번 포트 연결
# --name my-nginx : 컨테이너 이름을 my-nginx로 지정
# -d : 백그라운드에서 실행
docker run --name my-nginx -p 80:80 -d nginx

# 2. 호스트의 설정 파일을 컨테이너에 동기화 (Volume Mount)
# 실무에서는 설정 파일(conf)과 웹 리소스(html)를 호스트 폴더와 연결하여 관리합니다.
docker run --name custom-nginx \
  -v /path/to/your/html:/usr/share/nginx/html:ro \
  -v /path/to/your/nginx.conf:/etc/nginx/nginx.conf:ro \
  -p 80:80 -d nginx

```

---

### 3. Docker 사용 시 유료 서비스 및 비용 주의사항 (AWS 기준)

Docker를 활용해 Nginx를 띄울 때, 인프라 구성에 따라 다음과 같은 비용이 발생할 수 있습니다.

* **AWS ECR (Elastic Container Registry)**: 직접 커스텀한 Nginx 이미지를 저장할 경우, 저장 용량(GB당)과 데이터 전송량에 따라 **유료 과금**됩니다.
* **AWS Fargate (Serverless)**: EC2 없이 컨테이너를 바로 띄우는 Fargate 사용 시, 할당된 vCPU와 메모리 리소스 양에 따라 **초 단위로 과금**됩니다.
* **AWS App Runner**: 컨테이너화된 웹 앱을 배포하는 관리형 서비스로, 인스턴스 가동 시간 및 요청 횟수에 따라 **유료 전환**됩니다.

---

### 4. 언제 Docker를 쓰는 것이 더 좋은가?

1. **마이크로서비스 아키텍처(MSA)**: 여러 개의 웹 서비스와 프록시를 관리해야 할 때.
2. **CI/CD 자동화**: 빌드된 이미지를 테스트 서버와 운영 서버에 동일하게 배포해야 할 때.
3. **빠른 복구**: 서버 장애 시 새로운 인스턴스에서 즉시 동일한 설정을 복원해야 할 때.

반면, 단일 서버에서 아주 가벼운 용도로 Nginx만 고정적으로 사용한다면 OS 패키지 방식이 리소스 오버헤드가 적어 유리할 수 있습니다.

Next Step: Docker Compose를 활용한 Nginx와 Web Application 통합 관리

설정하신 규칙에 따라 깃허브 포맷으로 작성하였으며, Docker 사용 시 발생 가능한 유료 서비스 항목을 명시했습니다.

Next Step: Docker Compose 및 컨테이너 오케스트레이션 기초
