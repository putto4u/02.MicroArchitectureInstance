# Chapter 6-6. (재정립) UNION의 직관적 이해: 붙여넣기의 미학

`UNION`이 헷갈리는 이유는 `JOIN`과 비슷하게 "데이터를 합친다"고 표현하기 때문입니다. 하지만 두 명령어는 데이터를 합치는 **방향**이 완전히 다릅니다.

가장 쉬운 비유로 개념을 다시 잡겠습니다.

---

### 1. 방향의 차이: 옆으로 vs 아래로

데이터베이스를 '엑셀 파일'이라고 상상해 보십시오.

#### 1.1 JOIN (조인): 옆으로 넓어짐 (가로)

* **상황:** 엑셀의 A열에는 '이름'이 있고, B열에는 '학번'이 있습니다. 그런데 '전화번호'를 알고 싶어서 다른 시트에서 찾아와 C열에 **옆으로** 붙여넣었습니다.
* **결과:** 행(줄)의 수는 그대로인데, 정보가 늘어나서 테이블이 **옆으로 길어(넓어)**졌습니다.
* **핵심:** 정보의 **확장**입니다.

#### 1.2 UNION (유니온): 아래로 길어짐 (세로)

* **상황:** '1반 명단' 엑셀 파일과 '2반 명단' 엑셀 파일이 따로 있습니다. 이 둘을 합쳐서 '전체 학생 명단'을 만들고 싶습니다. 1반 명단 **맨 아래 끝에** 2반 명단을 복사해서 붙여넣었습니다.
* **결과:** 열(칸)의 개수는 그대로인데, 사람 수가 늘어나서 테이블이 **위아래로 길어**졌습니다.
* **핵심:** 목록의 **통합**입니다.

---

### 2. UNION이 성립하기 위한 '모양'의 조건

`UNION`은 단순히 두 개의 데이터를 위아래로 잇는 것이기 때문에, **두 테이블의 모양(와꾸)**이 반드시 맞아야 합니다. 엑셀에서 복사(Ctrl+C)해서 붙여넣기(Ctrl+V) 할 때 칸이 안 맞으면 데이터가 꼬이는 것과 같습니다.

**절대 규칙 2가지:**

1. **칸 수(컬럼 개수)가 같아야 한다.**
* A테이블은 [이름, 나이] 2개인데, B테이블은 [이름, 나이, 주소] 3개라면 합칠 수 없습니다. 위아래 짝이 안 맞기 때문입니다.


2. **데이터 성격(타입)이 같아야 한다.**
* A테이블 첫 번째 칸은 '이름(문자)'인데, B테이블 첫 번째 칸이 '나이(숫자)'라면 합칠 수 없습니다. 같은 열에는 같은 종류의 데이터가 들어가야 합니다.



---

### 3. UNION과 UNION ALL의 진짜 의미

이제 데이터를 합칠 때 **"중복을 어떻게 할 거냐"**만 결정하면 됩니다.

#### 시나리오: 쇼핑 영수증 합치기

오전에 '이마트'를 갔고, 오후에 '홈플러스'를 갔습니다. 오늘 산 물건을 하나의 리스트로 만듭니다.

* **이마트 구매:** 우유, 계란, 라면
* **홈플러스 구매:** 우유, 과자

#### 3.1 UNION (유니온) = "스마트한 통합" (중복 제거)

두 영수증을 합치면서 **겹치는 것을 뺍니다.**

> 결과: 우유, 계란, 라면, 과자 (총 4개)

* 컴퓨터가 "어? 우유가 두 번 있네? 하나는 지워야지"라고 생각하고 **검사하는 시간**이 걸립니다.

#### 3.2 UNION ALL (유니온 올) = "무지성 이어붙이기" (중복 허용)

그냥 영수증 두 장을 테이프로 **이어 붙입니다.**

> 결과: 우유, 계란, 라면, 우유, 과자 (총 5개)

* 컴퓨터가 내용을 확인하지 않고 그냥 갖다 붙이기만 하므로 **속도가 엄청나게 빠릅니다.**

---

### 4. 요약

| 구분 | JOIN | UNION |
| --- | --- | --- |
| **방향** | **횡(Horizontal)** | **종(Vertical)** |
| **동작** | 흩어진 정보(주소, 전화번호)를 긁어모아 **상세하게** 만듦 | 흩어진 목록(1반, 2반)을 긁어모아 **하나의 긴 리스트**로 만듦 |
| **비유** | 레고 조각을 **옆으로** 끼워서 완성품 만들기 | A4 용지 두 장을 **위아래로** 테이프 붙이기 |

# Chapter 6-7. 실전 예제로 익히는 UNION과 UNION ALL

개념을 확실히 잡기 위해 **'서울 지점 고객'**과 **'부산 지점 고객'** 명단을 하나로 합치는 상황을 가정해 보겠습니다.

---

### 0. 예제 데이터 준비 (가정)

두 개의 테이블이 존재합니다. **'박지성'** 고객은 서울과 부산 두 지점을 모두 이용한 이력이 있어 양쪽 테이블에 다 존재합니다.

**테이블 1: `seoul_customers` (서울 지점)**
| id | name | phone |
| :--- | :--- | :--- |
| 1 | 김철수 | 010-1111-1111 |
| 2 | 이영희 | 010-2222-2222 |
| **3** | **박지성** | **010-3333-3333** |

**테이블 2: `busan_customers` (부산 지점)**
| id | name | phone |
| :--- | :--- | :--- |
| **1** | **박지성** | **010-3333-3333** |
| 2 | 최민수 | 010-4444-4444 |

---

### 예제 1. UNION ALL (무조건 합치기)

**상황:** "서울과 부산, 어느 한 곳이라도 방문한 적 있는 **방문 횟수 기준**의 전체 명단이 필요하다." (중복이 있어도 됨)

```sql
SELECT name, phone
FROM seoul_customers
UNION ALL
SELECT name, phone
FROM busan_customers;

```

**[실행 결과]**

* **특징:** '박지성'이 두 번 출력됩니다. 데이터가 있는 그대로 위아래로 붙었습니다.

| name | phone |
| --- | --- |
| 김철수 | 010-1111-1111 |
| 이영희 | 010-2222-2222 |
| **박지성** | **010-3333-3333** |
| **박지성** | **010-3333-3333** |
| 최민수 | 010-4444-4444 |

---

### 예제 2. UNION (중복 제거)

**상황:** "DM(광고 문자)을 발송하려고 한다. 서울/부산 모두 방문했더라도 **문자는 한 번만** 보내야 하니 중복을 제거해라."

```sql
SELECT name, phone
FROM seoul_customers
UNION
SELECT name, phone
FROM busan_customers;

```

**[실행 결과]**

* **특징:** '박지성'이 한 명으로 합쳐졌습니다. (내부적으로 정렬 및 중복 제거 연산 수행)

| name | phone |
| --- | --- |
| 김철수 | 010-1111-1111 |
| 이영희 | 010-2222-2222 |
| **박지성** | **010-3333-3333** |
| 최민수 | 010-4444-4444 |

---

### 예제 3. (심화) 출신지 표기하기 (하드코딩 컬럼 추가)

**상황:** "합치긴 합치는데, 이 사람이 원래 서울 명단에 있었는지 부산 명단에 있었는지 **구분표**를 달아달라."

UNION을 할 때 컬럼 개수를 맞추기 위해 **가상의 컬럼(Literal Column)**을 만들어 넣는 실무 테크닉입니다.

```sql
SELECT '서울' AS location, name, phone  -- '서울'이라는 고정된 문자열 컬럼 생성
FROM seoul_customers
UNION ALL
SELECT '부산' AS location, name, phone  -- '부산'이라는 고정된 문자열 컬럼 생성
FROM busan_customers;

```

**[실행 결과]**

* **특징:** 원본 테이블에는 없던 `location`이라는 컬럼이 생겨서 어디 출신인지 식별 가능해집니다.

| location | name | phone |
| --- | --- | --- |
| **서울** | 김철수 | 010-1111-1111 |
| **서울** | 이영희 | 010-2222-2222 |
| **서울** | 박지성 | 010-3333-3333 |
| **부산** | 박지성 | 010-3333-3333 |
| **부산** | 최민수 | 010-4444-4444 |

---

### 예제 4. (주의) 에러가 발생하는 경우

**상황:** 위아래 컬럼의 **개수**나 **순서**가 안 맞는 경우.

```sql
-- [에러 발생]
-- 위에는 2개(이름, 전화번호)인데, 아래는 3개(이름, 전화번호, ID)를 가져오라고 함.
SELECT name, phone FROM seoul_customers
UNION ALL
SELECT name, phone, id FROM busan_customers; 

-- [논리적 오류 (실행은 되지만 망함)]
-- 위에는 (이름, 전화번호) 순서인데, 아래는 (전화번호, 이름) 순서로 적음.
-- 결과: 이름 칸에 전화번호가 들어가고, 전화번호 칸에 이름이 들어감.
SELECT name, phone FROM seoul_customers
UNION ALL
SELECT phone, name FROM busan_customers;

```

Next Step: 쿼리 안에 또 다른 쿼리가 들어가는 '서브쿼리(Subquery)'의 개념
