# SQL 데이터 결합: JOIN vs UNION

데이터베이스에서 여러 테이블의 데이터를 하나로 합쳐서 조회하는 방법은 크게 **JOIN**과 **UNION**으로 나뉩니다. 두 방식은 데이터를 합치는 방향과 논리가 완전히 다릅니다.

---

## 1. JOIN (수평 결합)

**JOIN**은 서로 다른 테이블을 가로 방향으로 붙이는 방식입니다. 두 테이블 사이에 공통된 연결 고리(보통 외래키)가 있을 때, 이를 기준으로 연관된 정보를 한 줄로 만듭니다.

### `employees` DB 실습 예제

사원 정보(`employees`)와 그 사원이 속한 부서 번호(`dept_emp`)를 합쳐서 조회해 보겠습니다.

```sql
SELECT e.emp_no, e.first_name, de.dept_no
FROM employees e
INNER JOIN dept_emp de ON e.emp_no = de.emp_no
LIMIT 10;

```

* **작동 방식**: `emp_no`가 일치하는 행들을 찾아 가로로 이어 붙입니다.
* **결과**: 사원 이름 옆에 부서 번호가 나란히 출력됩니다.

---

## 2. UNION (수직 결합)

**UNION**은 두 개 이상의 조회 결과를 세로 방향으로 쌓는 방식입니다. 서로 다른 테이블이라도 컬럼의 개수와 데이터 타입이 같다면 하나의 목록으로 합칠 수 있습니다.

### `employees` DB 실습 예제

현재 매니저인 사람들의 사번과 일반 사원들의 사번을 하나의 리스트로 합쳐서 보고 싶을 때 사용합니다.

```sql
-- 매니저 사번 목록
SELECT emp_no, 'Manager' AS role FROM dept_manager
UNION
-- 일반 사원 사번 목록
SELECT emp_no, 'Staff' AS role FROM dept_emp
LIMIT 10;

```

* **작동 방식**: 첫 번째 쿼리 결과 아래에 두 번째 쿼리 결과를 그대로 쌓습니다.
* **UNION vs UNION ALL**:
* `UNION`: 중복된 행을 제거하고 정렬합니다. (추가 연산 발생)
* `UNION ALL`: 중복을 허용하고 단순히 합칩니다. (속도가 더 빠름)



---

## 3. 핵심 차이점 요약

| 구분 | JOIN | UNION |
| --- | --- | --- |
| **결합 방향** | **가로 (Horizontal)** | **세로 (Vertical)** |
| **기준** | 공통 컬럼(Key)이 필요함 | 컬럼의 개수와 타입이 일치해야 함 |
| **결과** | 한 행에 더 많은 속성(열)이 생김 | 한 열에 더 많은 데이터(행)가 생김 |

---

## 4. AWS 환경에서의 성능 및 비용 고려사항

* **AWS RDS / Aurora (JOIN 성능)**:
* 대규모 테이블(`salaries` 등) 간의 JOIN은 많은 메모리와 CPU를 소모합니다. 조인 컬럼에 인덱스가 없다면 전체 테이블 스캔이 발생하여 성능이 급격히 저하됩니다.
* 비효율적인 조인은 DB 부하를 높여 **인스턴스 사양 업그레이드(유료 과금)**를 유도하므로 반드시 `EXPLAIN`으로 실행 계획을 확인해야 합니다.


* **AWS Athena (UNION 비용)**:
* Athena에서 여러 S3 경로의 데이터를 `UNION ALL`로 합칠 경우, 각 쿼리가 스캔하는 **전체 데이터 용량만큼 비용이 합산**되어 청구됩니다.
* 불필요한 `UNION` 대신 파티셔닝을 활용하여 스캔 범위를 줄이는 것이 **비용 절감**에 효과적입니다.


* **과금 주의**:
* JOIN이나 UNION 작업 중 발생하는 임시 데이터(Temporary Table)가 RDS 할당 용량을 초과하면 서비스 장애가 발생하거나 스토리지 확장 비용이 발생할 수 있습니다.


---
# SQL JOIN 및 UNION 실습 문제 및 모범 답안 (employees DB 기반)

이 교재는 `employees` 샘플 데이터베이스를 활용하여 JOIN(가로 결합)과 UNION(세로 결합)의 개념을 실습할 수 있도록 구성되었습니다.

---

## [Section 1] 실습 문제 (Exercise Problems)

### Part 1: JOIN 실습 (가로 결합)

두 개 이상의 테이블에서 연관된 속성을 결합하여 하나의 가로 행으로 만드는 연습입니다.

1. **사원명과 부서명 조회**: 모든 사원의 사번, 성명(first/last), 그리고 현재 소속된 부서의 이름을 출력하세요.
2. **매니저 연봉 정보**: 현재 부서 매니저들의 사번, 부서 번호, 그리고 그들의 현재 연봉을 조회하세요.
3. **직급별 평균 연봉**: 현재 재직 중인 사원들을 대상으로 직급(`title`)별 평균 연봉을 계산하세요.
4. **부서별 매니저 명단**: 모든 부서의 번호와 이름, 그리고 해당 부서의 현재 매니저 성명을 출력하세요.
5. **특정 부서원 입사일**: 부서명이 'Development'인 부서에 현재 속해 있는 사원들의 사번과 입사일을 조회하세요.

### Part 2: UNION 실습 (세로 결합)

두 개 이상의 쿼리 결과를 하나의 세로 목록으로 합치는 연습입니다.

6. **통합 ID 리스트**: 매니저 사번과 일반 사원 사번을 구분값('Manager'/'Staff')과 함께 하나의 리스트로 만드세요.
7. **성씨 그룹 합치기**: 성(`last_name`)이 'Facello'인 사원 그룹과 'Simmel'인 사원 그룹을 하나의 결과로 합치세요.
8. **매니저 재직 기록**: 역대 모든 매니저를 조회하되, 현재 매니저는 'Current', 과거 매니저는 'Old'라고 표시하여 합치세요.
9. **시스템 ID 목록**: 부서 번호(`dept_no`)와 사원 번호(`emp_no`)를 문자열로 형변환하여 하나의 컬럼에 나열하세요.
10. **급여 극단치 추출**: 전체 연봉 중 5만 달러 이하 사원 1명과 10만 달러 이상 사원 1명을 각각 뽑아 한 목록에 표시하세요.

---

## [Section 2] 모범 답안 (Model Answers)

### Part 1 답안 (JOIN)

```sql
-- 1. 사원명과 부서명 조회 (3중 조인)
SELECT e.emp_no, e.first_name, e.last_name, d.dept_name
FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON de.dept_no = d.dept_no
WHERE de.to_date = '9999-01-01';

-- 2. 매니저 연봉 정보
SELECT dm.emp_no, dm.dept_no, s.salary
FROM dept_manager dm
JOIN salaries s ON dm.emp_no = s.emp_no
WHERE dm.to_date = '9999-01-01' AND s.to_date = '9999-01-01';

-- 3. 직급별 평균 연봉
SELECT t.title, AVG(s.salary) AS avg_salary
FROM titles t
JOIN salaries s ON t.emp_no = s.emp_no
WHERE t.to_date = '9999-01-01' AND s.to_date = '9999-01-01'
GROUP BY t.title;

-- 4. 부서별 매니저 명단
SELECT d.dept_no, d.dept_name, e.first_name, e.last_name
FROM departments d
JOIN dept_manager dm ON d.dept_no = dm.dept_no
JOIN employees e ON dm.emp_no = e.emp_no
WHERE dm.to_date = '9999-01-01';

-- 5. 특정 부서(Development) 사원 입사일
SELECT e.emp_no, e.hire_date, d.dept_name
FROM employees e
JOIN dept_emp de ON e.emp_no = de.emp_no
JOIN departments d ON de.dept_no = d.dept_no
WHERE d.dept_name = 'Development' AND de.to_date = '9999-01-01';

```

### Part 2 답안 (UNION)

```sql
-- 6. 통합 ID 리스트
SELECT emp_no, 'Manager' AS role FROM dept_manager
UNION
SELECT emp_no, 'Staff' AS role FROM dept_emp;

-- 7. 성씨 그룹 합치기
SELECT emp_no, first_name, last_name FROM employees WHERE last_name = 'Facello'
UNION
SELECT emp_no, first_name, last_name FROM employees WHERE last_name = 'Simmel';

-- 8. 매니저 재직 기록
SELECT emp_no, 'Current' AS status FROM dept_manager WHERE to_date = '9999-01-01'
UNION ALL
SELECT emp_no, 'Old' AS status FROM dept_manager WHERE to_date != '9999-01-01';

-- 9. 시스템 ID 목록 (형변환 활용)
SELECT dept_no AS id_list FROM departments
UNION
SELECT CAST(emp_no AS CHAR) FROM employees LIMIT 100;

-- 10. 급여 극단치 추출
(SELECT emp_no, salary, 'Low' FROM salaries WHERE salary < 50000 LIMIT 1)
UNION
(SELECT emp_no, salary, 'High' FROM salaries WHERE salary > 100000 LIMIT 1);

```

---

## AWS 인프라 비용 및 운영 가이드

1. **AWS RDS (JOIN 성능 최적화)**:
* 1번과 5번 문제와 같은 다중 JOIN은 인덱스 유무에 따라 성능이 극명하게 갈립니다. `emp_no`와 `dept_no` 컬럼에 인덱스가 없다면 RDS의 CPU 사용률이 급증하며, 이는 **프로비저닝된 인스턴스 사양 초과 및 성능 저하**를 일으킵니다.


2. **AWS Athena (UNION 스캔 비용)**:
* Athena에서 `UNION`을 사용하면 내부적으로 각 `SELECT` 문을 실행한 후 결과를 합칩니다. 각 쿼리가 읽어들이는 데이터의 총합이 곧 **과금 기준(S3 Data Scanned)**이 되므로, 가급적 `WHERE` 절을 사용하여 데이터 스캔 범위를 최소화해야 비용을 아낄 수 있습니다.


3. **과금 관리 주의사항**:
* **UNION**은 중복 제거를 위해 메모리 내 정렬 작업을 수행하므로 자원을 많이 소모합니다. 중복이 발생할 일이 없는 데이터라면 **UNION ALL**을 사용하는 것이 DB 부하를 낮추고 **과금을 유발하는 불필요한 자원 사용을 줄이는** 지름길입니다.
* 실습이 끝난 후에는 반드시 RDS 인스턴스를 **삭제(Terminate)**하십시오. 인스턴스를 중지(Stop)해도 스토리지 할당 비용은 계속 청구됩니다.


---
